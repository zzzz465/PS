package main

/*
백준 14586 번
N 개의 도미노 존재
각 도미노는 h 높이
도미노를 좌/우 로 넘어뜨릴 수 있음

X 위치의 H 높이 도미노를 좌/우로 쓰러트리면, x-h 와 x 사이 도미노는 좌/우로 넘어진다 -> recursive 하게 넘어질 수 있음

최소한의 횟수로 도미노를 전부 무너뜨리려면, 몇 번 해야하는가?

단, 도미노의 개수는 최대 300개 -> 경우의 수 찾기도 가능할지도?
도미노의 위치는 1 부터 20억까지
	도미노는 무조건 붙어있지 않고, 서로 떨어져 있을 수 있다!

----
항상 가장 큰 것부터 쓰러뜨리는건 어떨까?
큰 도미노를 기준으로, 어디를 쓰러뜨릴 수 있을 지 파악하는건 어떨까?
작은 걸 쓰러뜨리는게 큰걸 쓰러뜨리는 것 보다 유리한 경우가 있는가? -> [있음]
	작은 것을 이용해서 큰 것을 쓰러뜨릴 수 있다면?
		1 ..(100 거리)... 100 1 1 1 1 1 1 <- 이거만 쓰러뜨리면 된다.

분할정복 가능한가?
	바텀업 방식으로 가능한가? 메모하면?
	2^300 은 절대 시간제한 내로 알아낼 수 없다.

A와 B 도미노가 있고, A > B 일 때, 경우 의 수는 2가지?
1. B가 A 의 범위 안에 있을 경우
2. B가 A 범위 밖에 있을 경우
	1 100 1 ...(50 거리?)... 1 의 경우, 3번째는 4번째와 연관 없지만, 100 을 이용하여 쓰러뜨릴 수 있다.

==핵심은, 한 쪽으로 밀면, 다른 것들도 전부 한 쪽으로 밀린다는 것이다==
	만약 그렇다면, 전체 탐색을 해도 되는게 아닐까?
		한 쪽으로 밀었을 때, 같은 방향으로 넘어졌을 때 가장 멀리까지 영향을 주는 것을 선정한다 -> 이를 "연쇄작용" 이라고 부르자.
			좌표 + 높이 로 계산 가능
			이 것을 반복하면 되지 않을까? 이 방식이면 많은 시행착오를 스킵할 수 있을 것이다.

랜덤으로 하나 선택하고, 좌/우 로 넘어뜨린 다음 "연쇄작용" 을 계산한다.
이후 남은 것 중 하나를 다시 선택해서, "연쇄작용" 일으키고... 완탐해야?하나?

이러면 1 _ 1 _ 1 _ ... 1 _ 1 이런식으로 하면 2^300 에 의해 시간초과가 뜰 것이다.
	= 그룹을 쪼개야 한다.

그룹은 어떻게 쪼개는가? -> 이게 맞나? 좀 더 단순하게 안되나?
greedy 하게 하면 가능할까? 안될거같은데?

3개, 4개, 5개 일 때 해보자.

3 1 1 -> 3개를 오른쪽으로
1 3 1 -> 2번
1 1 ___ 3 -> 2번

해답은... https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ehddml1229&logNo=221010915778 여기에
DP 쓰는거라고 하네.

 */

func main() {

}
